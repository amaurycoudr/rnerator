import { map, pipe } from 'ramda';
import { ENTRY, SANDBOX } from '../const';
import { Extension, NamePath } from '../type/type';
import { getFolderFiles } from './folder';
import JsTsFile from '../JsTsFile/JsTsFile';
import { getNoTextIfJs } from './string';

const getFileStart = (extension: Extension) =>
  `// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.` +
  `\n` +
  `/* eslint global-require: off */` +
  `${getNoTextIfJs(extension)("\nimport { FC } from 'react'")}${getNoTextIfJs(
    extension
  )(
    '\ntype SandBoxInfo = { name: string; location: string; component: FC };'
  )}`;

const fileEnd = '\nexport default data;';

export const getSandboxPaths = () => {
  const files: string[] = [];
  getFolderFiles('.', files);
  return files.filter((file) => file.includes(`.${SANDBOX}.`));
};

export const generateData = (extensions: Extension) => (sandboxes: string[]) =>
  `${getFileStart}const data${getNoTextIfJs(extensions)(
    ': SandBoxInfo[]'
  )} = [${sandboxes.join(',')}];${fileEnd}`;

class Sandbox extends JsTsFile {
  constructor(path: string) {
    if (!path.includes(SANDBOX)) throw new Error('Invalid sandbox path');
    super(path, true);
  }

  getString = () => pipe(this.getInfo, Sandbox.getStringFromInfo)();

  private static getStringFromInfo = ({ name, path }: NamePath) =>
    '{' +
    `name:"${name}",` +
    `location:"${path}",` +
    `component: require("${path}").default` +
    '}';

  private getInfo = (): NamePath => ({
    name: this.getName(),
    path: this.getRelativePath(),
  });

  private getName = () =>
    this.path.replace(`.${SANDBOX}.${this.extension}x`, '').split('/')[
      this.path.split('/').length - 1
    ];

  private getRelativePath = () => this.path.replace(ENTRY, '..');

  static new = (path: string) => new Sandbox(path);
}

export default Sandbox;

export const generateSandboxFilesContent = (extension: Extension) =>
  pipe(
    map((path: string) => Sandbox.new(path).getString()),
    generateData(extension)
  );
